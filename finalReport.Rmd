---
title: "VCF : `r params$vcf` "
output:    
  html_document:
    toc: true
    toc_depth: 2
date: '`r format(Sys.Date(), "Report created on %B %d, %Y")`'
author: 'Generated by Rmd script authored by Khalid BELKHIR'
always_allow_html: true
header-includes:
   - \usepackage{longtable}     
   - \usepackage{booktabs}     
   - \usepackage{float}     
   - \usepackage[table]{xcolor}     
   - \usepackage{caption}
   - \usepackage{longtable}

params: 
    vcf: "test.vcf.gz"
    popMap: ""
    globalmaxMissing: 1
    globalminMAF: 0
    maxLD: 0.8
    chr_geno_plot: 1
    start_geno_plot: 1
    maxSnp_geno_plot: 500
    expectedK: 3
    demoPOP1: 1
    demoPOP2: 2
    testModel: "IMexp"
    optiMethod: "optimize"#"dual_anneal"
    palette: "Set3"
    seed: 4321
---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{r, setup, include=FALSE}
 #Rscript -e 'rmarkdown::render("finalReport.Rmd", clean=FALSE, params = list(vcf="/media/khalid/9C33-6BBD/Laura/populations.snps.vcf.gz", #popMap="/media/khalid/9C33-6BBD/Laura/popmap.txt", expectedK=3), output_format = "html_document" )'

library(SNPRelate)
library(SeqArray)
library(Rtsne)
library(RColorBrewer)
library(ggplot2)
library(ggalt)
library(gplots)
library(pophelper)
library(reticulate)
library(dplyr)
library(kableExtra)
library(pander)
library(ggtree)
library(ComplexHeatmap)

knitr::opts_chunk$set(
  comment = '', fig.width = 8, fig.height = 8, echo =FALSE
)

use_python("/usr/bin/python3")

filtredfile=paste0("/tmp/",basename(params$vcf),"-minMAF=",params$globalminMAF,"-maxMissing=",params$globalmaxMissing,"-LD", params$maxLD, ".vcf.gz")
gds_file = paste0(tempfile(),".gds")
Sys.setenv(vcf=params$vcf)
Sys.setenv(globalmaxMissing=params$globalmaxMissing)
Sys.setenv(globalminMAF=params$globalminMAF)
Sys.setenv(maxLD=params$maxLD)
Sys.setenv(expectedK=params$expectedK)
Sys.setenv(filtredfile=filtredfile)
outimage = paste0(tempfile(),".png")
Sys.setenv(outimage=outimage )
Sys.setenv(seed=params$seed)

if (params$popMap != "") popmap=read.table(params$popMap, header=F, sep='\t', stringsAsFactors=F)


evaluate=TRUE
```

\newpage

```{bash, filter, eval = FALSE, echo = FALSE}
#on fait tout dans filterLD
#echo "Filtering vcf file for minMAF and maxMissing :" ;
#echo " vcftools --gzvcf $vcf --max-missing $globalmaxMissing --maf $globalminMAF --recode --recode-INFO-all  --stdout | bgzip -c > ${filtredfile} ";
#vcftools --gzvcf $vcf --max-missing $globalmaxMissing --maf $globalminMAF --recode --recode-INFO-all  --stdout 2>/dev/null | bgzip -c  > ${filtredfile}
#bcftools index ${filtredfile}

```
  
## Filter snp where LD >  `r params$maxLD`  min MAF= `r params$globalminMAF` max-missing = `r params$globalmaxMissing`

```{r, filterLD, eval=evaluate, echo=FALSE}

tmp_gds_file = tempfile()

seqVCF2GDS(params$vcf, tmp_gds_file, verbose=FALSE, storage.option="LZ4_RA", parallel = 8)

genofile <- seqOpen(tmp_gds_file)

snpset <- snpgdsLDpruning(genofile,autosome.only=FALSE, maf = params$globalminMAF, missing.rate=params$globalmaxMissing, ld.threshold=params$maxLD, verbose=F)
     
# get SNP ids
snpset.id <- unlist(snpset, use.names=FALSE)

#filter the snpset
seqSetFilter(genofile, variant.id=snpset.id)
seqExport(genofile, gds_file,verbose=F)

# convert back to vcf
seqGDS2VCF(genofile, filtredfile, verbose=F)

seqClose(genofile)

# Create bed file for fastStructure
genofile <- seqOpen(gds_file)
seqGDS2BED(genofile, out.fn=filtredfile,verbose=F)
seqClose(genofile)



unlink(tmp_gds_file)

```
## Calculate stats with bcftools :
```{bash, bcfStats, eval = evaluate, echo = FALSE, warning=FALSE, error=FALSE, message=FALSE}

 outstats=$(mktemp -u);
 outdir=$(mktemp -u -d);
 
 echo -e "bcftools stats --threads 4 -s - \n $filtredfile   >  $outstats" ;
 bcftools stats --threads 4 -s - $filtredfile 2>/dev/null >  $outstats;
 
 echo "Plot the stats :";
 vcfshortName=$(basename $vcf)
 echo -e 'plot-vcfstats -P -p  $outdir  -t \n "${vcfshortName}_maxLD=${maxLD}_minMAF=${globalminMAF}_maxMissing=$globalmaxMissing" $outstats';
 plot-vcfstats -P -p  $outdir  -t "${vcfshortName}_maxLD=${maxLD}_minMAF=${globalminMAF}_maxMissing=$globalmaxMissing" $outstats ;

 convert -size 1200x1000 \( $outdir/depth.0.png  $outdir/substitutions.0.png $outdir/hwe.0.png +smush +400 \) \
          \( $outdir/snps_by_sample.0.png $outdir/indels_by_sample.0.png +smush +150 \) \
          \( $outdir/dp_by_sample.0.png $outdir/singletons_by_sample.0.png +smush +150 \) \
          \( $outdir/hets_by_sample.0.png  $outdir/tstv_by_sample.0.png   +smush +150 \) -append  $outimage

```

```{r, drawBcfstats,  eval = evaluate, echo = FALSE}
knitr::include_graphics(outimage)
```

## Genotypes heatmap on selected ctg/window :

```{r, genotype_plot, out.width="100%",  out.height="200%"}

#filter for chr start pos and nb snps
genofile <- seqOpen(gds_file)
l=seqGetData(genofile, c("chromosome", "position", "variant.id"))
df <- data.frame(matrix(unlist(l), ncol=length(l), byrow=F))
colnames(df) = c("chr","position","ident")

#params$chr_geno_plot can be a contig name or a contig index in the list of ctgs (dans quel ordre ?!!!)
if (params$chr_geno_plot %in% df$chr) {chr = params$chr_geno_plot
}else {
  chr=unique(df$chr)[params$chr_geno_plot]}
snps = (df %>% filter(chr== chr & position >  params$start_geno_plot))$ident
if (length(snps) > params$maxSnp_geno_plot) {snps = snps[1:params$maxSnp_geno_plot]}
seqSetFilter(genofile, variant.id=snps)
infos = seqGetData(genofile, c("sample.id", "position", "variant.id","genotype"))
seqClose(genofile)
geno <- infos[[4]]
firstSnpPos=infos[[2]][1]
lastSnpPos=infos[[2]][length(infos[[2]])]

#this is for bi-allelic snp codage in 0 (ref/ref) , 1 (ref/alt) and 2 (alt/alt)
geno_matrix <- geno[1,,]+ geno[2,,]
keylabels=c("REF/REF","REF/ALT","ALT/ALT")
my_palette =c("#d4b9da","#e7298a","#980043")

#this is for multi-allelic snp codage in 2 (ref/ref) , 1 (ref/alt) and 0(alt/alt)
geno_matrix <- (geno[1,,] == 0) + (geno[2,,] == 0)
keylabels=c("ALT/ALT","REF/ALT","REF/REF")
my_palette =c("#980043","#e7298a","#d4b9da")

#geno_matrix[genos == "NA"] <- NA
rownames(geno_matrix)=infos[[1]]
colnames(geno_matrix)=infos[[2]]

sample.id1 = rownames(geno_matrix)
rownames(popmap) = popmap[,1]
pop_code1= popmap[sample.id1, 2]

#brewer return a min of 3 colors
ncolors = max(length(unique(pop_code1)), 3)
popc <- brewer.pal(n = ncolors, name = params$palette)
popc = popc[1:length(unique(pop_code1) ) ] 
names(popc) = unique(pop_code1)
pop_color1 = popc[pop_code1]
names(pop_color1) = sample.id1

titre = paste0("Genotypes Contig: ", chr, " start: ", params$start_geno_plot, " snps: ", length(snps))
titre = paste0("Contig: ", chr,  " snps: ", ncol(geno_matrix), " 1st pos: ", firstSnpPos, " last pos:", lastSnpPos )


#heatmap.new(geno_matrix, Rowv=TRUE, Colv=TRUE, main=titre,RowSideColors=pop_color1, margins=c(5,1,0), scale="none", verbose=F,col = my_palette)
#par(xpd=TRUE)
#leg1=legend(x="bottomleft", inset=c(0,0.95), legend= keylabels,  fill=c(my_palette,"#FFFFFF"), title="Genotypes")
#leg2=legend(x="bottom" ,inset=c(0,0.95) , legend= names(popc), title="Populations",  fill=popc, ncol = 5)

ddc = apply(geno_matrix, 2, function(snp) sum(! is.na(snp)))
names(ddc)=""

ddr = apply(geno_matrix, 1, function(snp) sum(! is.na(snp)))
names(ddr)=""

column_ha = HeatmapAnnotation(nonmissingsamples = anno_barplot(ddc) )
row_ha    = rowAnnotation( nonmissingsnps = anno_barplot(ddr))
pops_ha   = rowAnnotation(pops= pop_code1, col=list(pops=popc))

my_palette=c(my_palette,"#FFFFFF")

Heatmap(geno_matrix, name = "Genotypes", row_names_side = "left", top_annotation = column_ha, right_annotation = row_ha, left_annotation =pops_ha ,show_column_dend = FALSE, show_row_dend = FALSE, cluster_rows = FALSE, cluster_columns = FALSE, show_column_names=FALSE, column_title=titre, na_col = "white", col=structure(  my_palette,  names=c(2,1,0,NA)), row_names_gp = gpar(fontsize = 8) )#genoWindow()$keylabels))


```
  
## Dimension reduction with PCA:

```{r, PCA, out.width="100%", echo=FALSE, warning=FALSE}
#genofile <- snpgdsOpen(gds_file)
genofile <-  seqOpen(gds_file)
PCA1 <- snpgdsPCA(genofile,  snp.id=NULL, maf=NaN, missing.rate=0.2, num.thread=8, verbose=FALSE, autosome.only=FALSE)
sample.id1 <- PCA1$sample.id

#snpgdsClose(genofile)
seqClose(genofile)

if (params$popMap == "" ){
  pop_color1= "black"
  pop_code1 = rep(1, length(sample.id1) ) 
  popc=data.frame("black"); rownames(popc)="undef"
} else {

pop_code1= popmap[which(popmap[,1] %in% sample.id1), 2]
#brewer return a min of 3 colors
ncolors = max(length(unique(pop_code1)), 3)
popc <- brewer.pal(n = ncolors, name = params$palette)
popc = popc[1:length(unique(pop_code1) ) ] 
names(popc) = unique(pop_code1)
pop_color1 = popc[pop_code1]
names(pop_color1) = sample.id1
}

# make a data.frame
tableau = data.frame(sample.id = sample.id1,
                   pop = factor(pop_code1),
                   Axe1 = PCA1$eigenvect[,1],    # the first eigenvector
                   Axe2 = PCA1$eigenvect[,2],    # the second eigenvector
                   Axe3 = PCA1$eigenvect[,3],    # the 3 eigenvector
                   Axe4 = PCA1$eigenvect[,4],    # the 4 eigenvector
                   Axe5 = PCA1$eigenvect[,5],    
                   Axe5 = PCA1$eigenvect[,6], 
                   Axe5 = PCA1$eigenvect[,7], 
                   Axe5 = PCA1$eigenvect[,8], 
                   Axe5 = PCA1$eigenvect[,9], 
                   Axe5 = PCA1$eigenvect[,10], 
                   couleur = pop_color1,
                   stringsAsFactors = FALSE) 
```

```{r, plotEigen}         

barplot(PCA1$eigenval[1:20], main=paste0("PCA top 20 eigenvalues maxLD=",params$maxLD ," minMAF=", params$globalminMAF," maxMissing=", params$globalmaxMissing), col=heat.colors(25),names.arg=paste("axe",seq(1:length(PCA1$eigenval[1:20])), sep=""))
```

```{r, PCAfirst2axes}
df = tableau[,c(3, 4 ,1,2, 13)]
colnames(df) = c("axe1","axe2","samples","pops","couleur")


fit_cluster_hierarchical=hclust(dist(scale(df[,c(1,2)])))
nbpops=length(unique(df$pops) )
 #if (nbpops == 1) nbpops = 2

h_clusters = factor(cutree(fit_cluster_hierarchical, k=nbpops))
#we can also use the given expectedK
h_clusters = factor(cutree(fit_cluster_hierarchical, k=params$expectedK))
df = cbind(df, clusters = h_clusters)

plot_cluster=function(data, var_cluster,  palette, shape)
{ #https://luisdva.github.io/rstats/Grouping-points/
  # find_hull <- function(df) df[chull(df$axe1, df$axe2), ]
  # hulls <- ddply(data, which_hull, find_hull)
  
  ggplot(data, aes_string(x="axe1", y="axe2", color=var_cluster, shape=shape)) + ggtitle(paste0("maxLD=",params$maxLD," maxMissing=", params$globalmaxMissing," minMaf=", params$globalminMAF)) +
  geom_point(size=3) +
  guides(colour=guide_legend(override.aes=list(size=6))) +
  xlab("axe1") + ylab("axe2") +
  ggtitle("") +
  #theme_light(base_size=20) +
  theme(axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        legend.direction = "horizontal", 
        legend.position  = "bottom",
        legend.box       = "horizontal") + 
  scale_colour_brewer(palette = palette) 
}

#colorier les points avec info pop et entourer les clusters
  if(nbpops > 1)
  {    
      plot_p=plot_cluster(df, "pops", params$palette,  "clusters" )
  }  else {
      plot_p=ggplot(df, aes_string(x="axe1", y="axe2", shape="clusters")) +  geom_point(size=3) 
  }
  #if (input$pcashowLabels)   
  plot_p = plot_p + geom_text(aes(label=samples),hjust=0,vjust=0.2)
  
  #if (input$pcashowClusters) 
  plot_p = plot_p + geom_encircle(aes_string(group = "clusters"), s_shape = 1, expand = 0,alpha = 0.2, color = "red", show.legend = FALSE) 
  
  plot_p + ggtitle(paste0("maxLD=",params$maxLD," minMAF=", params$globalminMAF," maxMissing=", params$globalmaxMissing))

```

```{r, PCApairs}

labels = paste("axe", 1:5, sep='')
labels = paste(labels,format(round(PCA1$eigenval[1:5], 2) ), "%")
pairs(tableau[,3:7],lower.panel=NULL, col = tableau$couleur,  labels = labels, main=paste0("maxLD=",params$maxLD," minMAF=", params$globalminMAF," maxMissing=", params$globalmaxMissing))

```

\newpage

## Calc IBS pairwise distances, cluster analysis and determine the groups by a permutation score
  
```{r, IBS, out.width="100%"}
#genofile <- snpgdsOpen(gds_file)
genofile <- seqOpen(gds_file)

sample.id1 <- PCA1$sample.id
ibs  <- snpgdsIBS(genofile, sample.id=sample.id1, snp.id=NULL,num.thread=8, verbose=FALSE, autosome.only=FALSE)

#snpgdsClose(genofile)
seqClose(genofile)

colnames(ibs$ibs) = ibs$sample.id
rownames(ibs$ibs) = ibs$sample.id


couleurs = tableau$couleur
head(couleurs[ibs$sample.id])
heatmap.2(ibs$ibs, 
          col=terrain.colors(20), 
          RowSideColors = couleurs, 
          ColSideColors = couleurs, trace="none")
par(lend = 1)           # square line ends for the color legend
legend("bottomright", ncol=2,  legend = names(popc), col = popc, lty= 1,lwd = 5, bty="n") 


set.seed(params$seed)
ibs.hc <- snpgdsHCluster(ibs)

# Determine groups of individuals automatically
rv <- snpgdsCutTree(ibs.hc)
op <- par(cex=0.35)
plot(rv$dendrogram, leaflab="perpendicular",  main="Hclustering and automatic grouping")
par(op)
```
\newpage
  
## Pairewise Fst:

Pairewise Fst estimate from Weir and Cockerham's 1984 paper. *Above digonal: mean Fst estimate  *Under diagonal: weighted Fst estimate

```{r, Fstpairs, echo=FALSE}

#genofile <- snpgdsOpen(gds_file)
genofile <- seqOpen(gds_file)

sample.id <- read.gdsn(index.gdsn(genofile, "sample.id"))
if ( (length(sample.id) != length(popmap[,1])) | (length(setdiff(sample.id, popmap[,1])) > 0) )    print("The list of samples in popMap is different from samples in the VCF. Only samples in both files will be analysed.")


    rownames(popmap) = popmap[,1]
    popc <- unique(popmap[,2])
   
    fstpairs = matrix(0,nrow=length(popc),ncol=length(popc),dimnames= list(popc, popc) )
    
    for (i in 1:(length(popc)-1) )
    {
      for (j in (i+1):length(popc) )
      {
         pop1 = popc[i]
         pop2 = popc[j]
         indpop1pop2 = popmap[popmap[,2] %in% c(pop1,pop2),1]
         
         fst <- snpgdsFst(genofile, sample.id=indpop1pop2, population=as.factor(popmap[rownames(popmap) %in% indpop1pop2,2]),  autosome.only=F,  method="W&C84",  remove.monosnp=T, verbose=FALSE)
         fstpairs[i,j] = fst$MeanFst
         fstpairs[j,i] = fst$Fst 
      }
    }

    #snpgdsClose(genofile)
    seqClose(genofile)
```

```{r, printHtmlFstpairs, eval=knitr::is_html_output()}

    DT::datatable( as.data.frame(fstpairs), caption = paste0("Data filtered : maxLD=",params$maxLD," minMAF=",params$globalminMAF," maxMissing=",params$globalmaxMissing), options = list(pageLength = 30, searching = FALSE) )
```

```{r, printlatexFstpairs, eval=knitr::is_latex_output()}
 pandoc.table(as.data.frame(fstpairs), caption = paste0("Data filtered : maxLD=",params$maxLD," minMAF=",params$globalminMAF," maxMissing=",params$globalmaxMissing),)
```

```{r, plotNJtree,  out.width="100%"}
      forme   = "rectangular" 
	    title=paste0("NJ plot on pairewise Fst. Data filtered : maxLD=",params$maxLD," minMAF=" , params$globalminMAF," maxMissing=",params$globalmaxMissing)
	    if (nrow(fstpairs) < 3)  return(NULL)
      distance = fstpairs
		  tree = ape::nj(distance)
		  p <- ggtree(tree,layout=forme) + geom_text(aes(label=label), size=3, color="purple", hjust=-0.3) + theme_tree2("gray86") +ggtitle(title)
		  plot(p)
```
  
## Faststructure :

```{bash, runfaststructure, eval = evaluate, echo = FALSE}
#/opt/biotools/bin/plink --vcf $filtredfile --make-bed --double-id --allow-extra-chr --chr-set 950 --out $filtredfile 1>/dev/null

rm ${filtredfile}-fastStr*

for K in `seq 2 $expectedK` 
do
      if [[ $K < ${expectedK} ]]
      then
       python /opt/biotools/bin/fastStructure/structure.py -K $K --prior=simple --cv 0 --input=$filtredfile --output=${filtredfile}-fastStr --seed=$seed &
      else 
       python /opt/biotools/bin/fastStructure/structure.py -K $K --prior=simple --cv 0 --input=$filtredfile --output=${filtredfile}-fastStr --seed=$seed
      fi 
done

```

```{r, fastStructurePlot, out.width="100%"}
files <- Sys.glob(paste0(filtredfile,'-fastStr*.meanQ') )
    qlist <- readQ(files)

    cmd = paste0("python /opt/biotools/bin/fastStructure/chooseK.py --input=",filtredfile,"-fastStr ")
    ModelComplexity=system(cmd, intern=TRUE)
    
    titre = paste0("maxLD=",params$maxLD," minMAF=",params$globalminMAF, " maxMissing=",params$globalmaxMissing," ", paste0(ModelComplexity, collapse=" ") )

    kelly <- c("#BE0032","#F3C300","#875692","#F38400","#A1CAF1","#C2B280","#848482","#008856","#E68FAC","#0067A5","#F99379","#604E97","#F6A600","#B3446C","#DCD300","#882D17","#8DB600", "#654522","#E25822","#2B3D26")

    #ttt = system(paste0('vcf-query -l ', filteredFile), intern=T)
    #qlist <- lapply(qlist,"rownames<-", ttt)

    #http://www.royfrancis.com/pophelper/articles/index.html#plotq
    qlist = lapply(qlist,"rownames<-",sample.id)
    haut = round(40 / length(qlist))
    nopops =T
    if ( params$popMap != ""){
      popGroups = popmap 
      if ((length(sample.id) == length(popmap[,1])) & (length(setdiff(sample.id, popmap[,1])) == 0) )
      {
      nopops = F 
      colnames(popGroups) = c('Indivs','Pops')
      p = plotQ(qlist,returnplot=T, exportplot=F,basesize=11, grplab=popGroups[,2,drop=FALSE],grplabsize=2,linesize=0.8,pointsize=3, showindlab=T,useindlab=T, ordergrp=T, indlabangle=90,indlabvjust=1, height=haut, width=120, indlabsize=3, divsize=2, spbgcol="grey", imgoutput="join", panelspacer=0.4, splab=paste0("K=",sapply(qlist,ncol)),splabsize=20 , clustercol=kelly,barbordersize=0.2 , barbordercolour='white', showtitle=T, titlesize=6,titlelab= titre)
      } 
      else 
      {
       print ("The list of samples in popMap is different from samples in the VCF. The population info is ignored .")
       nopops = T
      }
    }
    if ( params$popMap=="" | nopops)    
      p= plotQ(qlist,returnplot=T,exportplot=F,quiet=F,basesize=11,linesize=0.8,pointsize=3,  height=haut, width=140,indlabsize=, divsize=2, spbgcol="grey", imgoutput="join", panelspacer=0.4, splab=paste0("K=",sapply(qlist,ncol)),splabsize=20 , indlabangle=90, indlabvjust=1, showindlab=T,useindlab=T, clustercol=kelly,barbordersize=0.2 , barbordercolour='white', showtitle=T, titlesize=6, titlelab= titre)
  
  gridExtra::grid.arrange(p$plot[[1]])
```

```{r, bestK}
bestlikelihood=-99999999
bestK =2
for (K in 2:params$expectedK)
{
fic = paste0(filtredfile,"-fastStr.",K, ".meanQ")
    
cmd = paste0("grep  'Marginal Likelihood =' ", filtredfile,"-fastStr.",K,".log")
likelihood =system(cmd, intern=T)
likelihood = as.numeric(unlist(strsplit(likelihood,"= "))[2])
if (likelihood > bestlikelihood) {bestlikelihood=likelihood; bestK=K }
}


fic = paste0(filtredfile,"-fastStr.",bestK, ".meanQ")
if  ( file.exists(fic) )  {
        df = read.table(fic, header=F)
       
        if ( params$popMap != "") {
          if ((length(sample.id) == length(popmap[,1])) & (length(setdiff(sample.id, popmap[,1])) == 0) )
          {
            rownames(df)  = sample.id #ttt
            colnames(df) =  paste0("cluster", 1:bestK)
            df = cbind( Popmap =popmap[popmap[,1] %in% sample.id,2], df, stringsAsFactors=F)
          }
          else print("The list of samples in popMap is different from samples in the VCF. The population info is ignored .")
        }
}

```

\captionsetup[table]{labelformat=empty}

```{r, KablepourDT, results='asis', eval=(knitr::opts_knit$get('rmarkdown.pandoc.to') == 'latex'), echo = FALSE}    
    knitr::kable(df, "latex", booktabs = TRUE, longtable = TRUE, caption = paste0("For k=",bestK," Likelihood= ",likelihood), escape=F) %>%
 kable_styling(latex_options = c("hold_position", "repeat_header"),  font_size = 12)

```
\newpage

```{r, fastStructureDT, results='asis', eval=knitr::is_html_output()}

#ne representer que le DT pour K avec meilleur likelihood

DT::datatable(df,  options= list(pageLength = 20, searching = FALSE), caption=paste0("For k=",bestK," Likelihood= ",likelihood,"  "))
cat("\n  \n")


#for (k in 2:params$expectedK)
#{
#  dt  = createDT(k) 
#  cat("### Table : for k= ", k, "\n  \n")
#  #cette fonction semble vouloir produire des screenshots si webshot est installé
#  knitr::knit_print(dt)
  
#  cat("\n  \n")
#}

#cette solution donne un html mal construit après
#res = lapply(2:params$expectedK, createDT)
#htmltools::tagList(res)

```
  

## Pairwise FS

```{python, importSFS, results = 'hide'}
from numpy import array
import matplotlib.pyplot as plt
import moments
import dadi
if r.params['popMap'] != "":    
    #la version de moments ne semble pas marcher sur des vcf de type population ou bien presence de données manquantes ?
    dd = moments.Misc.make_data_dict_vcf(r.filtredfile, r.params['popMap'], filter=False)
    if len(dd) == 0:
      dd = dadi.Misc.make_data_dict_vcf(r.filtredfile, r.params['popMap'], filter=False)
    pop_dict = {}
    fss = []
    FSlegends = []
    popinfo_file=open(r.params['popMap'])
    for line in popinfo_file:
        pop = line.split()[1]
        if pop in pop_dict:
            pop_dict[pop] += 1
        else:
            pop_dict[pop] = 1   
    pops = list(pop_dict.keys())      
    fig = 0
    #plt.figure(figsize=(8,8))
    #for pop1 in range(len(pops)):
    #for pop2 in range(pop1+1, len(pops)):
    pop1 = r.params['demoPOP1']
    pop2 = r.params['demoPOP2']
    fs = moments.Spectrum.from_data_dict(dd, [pops[pop1], pops[pop2]], [min(20,pop_dict[pops[pop1]]), min(20,pop_dict[pops[pop2]])], polarized=False)
    fss.append(fs)
    # Let's plot the fs.
    fig += 1
    
    #plt.suptitle(pops[pop1]+"-"+ pops[pop2]+" Fst: "+ '{:.4f}'.format(fs.Fst())+" S: "+  '{:.4f}'.format(fs.S()),fontsize=10)
    title = pops[pop1]+"-"+ pops[pop2]+" Fst: "+ '{:.4f}'.format(fs.Fst())+" S: "+  '{:.4f}'.format(fs.S())
    FSlegends.append(title)
    plt.clf()
    moments.Plotting.plot_single_2d_sfs(fs, vmin=0.1, out="/tmp/importFS"+str(fig)+".png", show=False)
         
            
```



```{r, InsertSFSplots,  eval = evaluate,  out.width="100%", results='asis'}
list_files=c()
for (i in 1:py$fig)
{
   cat(paste0(py$FSlegends[i], "\n")) 
   cat(paste0("![](", "/tmp/importFS", i, ".png)"), "\n\n  ")
   #list_files = c(list_files, paste0("/tmp/importFS",i,".png") )
}

#knitr::include_graphics(list_files)
```

## Demographic Inference with `r params$testModel` model using `r params$optiMethod ` optimization method

```{python, FSdemo, eval = evaluate}
a_max = 10.0 ; a_min = 0.1 ; a_start = 1.0 ;#beta-binomial alpha
b_max = 10.0 ; b_min = 0.1 ; b_start = 1.0 ;#beta-binomial beta
nu1_max = 20.0 ; nu1_min = 1e-3 ; nu1_start = 1.0 ;#current size of pop1
nu2_max = 20.0 ; nu2_min = 1e-3 ; nu2_start = 1.0 ;#current size of pop2
nu1e_max = 20.0 ; nu1e_min = 1e-3 ; nu1e_start = 1.0 ;#current size of pop1
nu2e_max = 20.0 ; nu2e_min = 1e-3 ; nu2e_start = 1.0 ;#current size of pop2
ne1_max = 20.0 ; ne1_min = 1e-3 ; ne1_start = 1.0 ;#size of pop1 after exponential change
ne2_max = 20.0 ; ne2_min = 1e-3 ; ne2_start = 1.0 ;#size of pop2 after exponential change
Ts_max = 12.0 ; Ts_min = 1e-10 ; Ts_start = 1.0 ;#duration of the period after split
Ti_max = 12.0 ; Ti_min = 1e-10 ; Ti_start = 1.0 ;#duration of the second period
m12_max = 20.0 ; m12_min = 1e-10 ; m12_start = 1.0 ;#migration from 2 to 1
m21_max = 20.0 ; m21_min = 1e-10 ; m21_start = 1.0 ;#migration from 1 to 2
nr_max = 1.00 ; nr_min = 1e-10 ; nr_start = 0.5 ;#fraction of the genome with reduced Ne
bf_max = 1.00 ; bf_min = 1e-3 ; bf_start = 0.5 ;#factor of Ne reduction
P_max = 1.00 ; P_min = 1e-10 ; P_start = 0.5 ;#1 - fraction of the genome with Me=0
O_max = 1.0 ; O_min = 1e-10 ; O_start=0.8 #fraction of SNPs accurately oriented relative to the outroup

import pandas as pds
df = pds.read_table("./modelspages/models_params.txt")
Model = r.params['testModel']
Mparams = df[df.Model == Model].lib

upper_bound=[]
lower_bound=[]
p0=[]
for i in Mparams:
     prm = i+"_min"
     val = globals()[prm]
     lower_bound.append(val)
     
     prm = i+"_max"
     val = globals()[prm]
     upper_bound.append(val)
     
     prm = i+"_start"
     val = globals()[prm]
     p0.append(val)          

import sys
sys.path.append('./momentsmodels/')

import moments_models_2pop
import moments.moments_inference_dualanneal
from inspect import getmembers, isfunction

func = dict(getmembers(moments_models_2pop, isfunction))[Model]

#if r.params['testModel'] == "IM":
#    func = moments.Demographics2D.IM
#    p0 = [0.5, 1.0, 1.0, 1.0, 1.0, 1.0]
#    upper_bound = [0.99, 100.00, 100.00,  10.00,  20.00,  20.00]
#    lower_bound = [0.010, 1.000, 1.000, 1.000, 0.001, 0.001]


p0 = moments.Misc.perturb_params(    p0, fold=1, upper_bound=upper_bound, lower_bound=lower_bound)

fs = fss[0]
if r.params['optiMethod'] == "optimize_log":
    popt = moments.Inference.optimize_log(
        p0,
        fs,
        func,
        lower_bound=lower_bound,
        upper_bound=upper_bound,
        verbose=0,
        maxiter=10
    )

if r.params['optiMethod'] =="optimize":
    popt = moments.Inference.optimize(p0, fs, func, lower_bound=lower_bound, upper_bound=upper_bound, verbose=0, maxiter=10)
  
if r.params['optiMethod'] == "optimize_log_lbfgsb":
    popt = moments.Inference.optimize_log_lbfgsb(p0, fs, func, lower_bound=lower_bound, upper_bound=upper_bound, verbose=0, maxiter=10)
      
if r.params['optiMethod'] == "dual_anneal":
    ##### Set optimization values
    maxiterGlobal=10 #maximum global search iterations - in each iteration, it explores twice the number of parameters
    accept=1 #parameter for acceptance distribution (lower values makes the probability of acceptance smaller)
    visit=1.01 #parameter for visiting distribution (higher values makes the algorithm jump to a more distant region)
    Tini=50 #initial temperature
    no_local_search=False #If set to True, a Generalized Simulated Annealing will be performed with no local search strategy applied
    local_method='L-BFGS-B' #local search method
    maxiterLocal=20 #maximum local search iterations
    popt = moments.moments_inference_dualanneal.optimize_dual_anneal(p0, fs, func, lower_bound=lower_bound, upper_bound=upper_bound,    no_local_search=no_local_search, local_method=local_method, local_maxiter=maxiterLocal,maxiter=maxiterGlobal, Tini=Tini, accept=accept, visit=visit, verbose=0, full_output=False)

print("Best-fit parameters: {0}".format(popt))

# Calculate the best-fit model AFS.
model = func(popt, fs.sample_sizes)

# Likelihood of the data given the model AFS.
ll_model = moments.Inference.ll_multinom(model, fs)
print("Maximum log composite likelihood: {0}".format(ll_model))
# The optimal value of theta given the model.
theta = moments.Inference.optimal_sfs_scaling(model, fs)
print("Optimal value of theta: {0}".format(theta))

plt.figure(figsize=(8,8))
moments.Plotting.plot_2d_comp_multinom(
    model, fs, vmin=1, resid_range=3, pop_ids=fs.pop_ids, out="/tmp/InferenceDemo"+Model+".png", show=False
)

#plt.close()
```

```{r, InsertDemoplot,  eval = evaluate, echo = FALSE, out.width="100%"}
image = paste0("/tmp/InferenceDemo",params$testModel,".png")
if (file.exists(image) ) knitr::include_graphics(image)
```

  
# Refs

### https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0056883
### https://www.biorxiv.org/content/biorxiv/early/2017/03/08/114884.full.pdf ====>  https://www.ncbi.nlm.nih.gov/pubmed/28718343
### https://towardsdatascience.com/dimensionality-reduction-for-data-visualization-pca-vs-tsne-vs-umap-be4aa7b1cb29

### Zheng X, Levine D, Shen J, Gogarten S, Laurie C, Weir B (2012). "A High-performance Computing Toolset for Relatedness and Principal Component Analysis of SNP Data." Bioinformatics, 28(24), 3326-3328. doi: 10.1093/bioinformatics/bts606.



### Anil Raj, Matthew Stephens, and Jonathan K. Pritchard. fastSTRUCTURE: Variational Inference of Population Structure in Large SNP Data Sets , (Genetics) June 2014 197:573-589

### package pophelper : http://www.royfrancis.com/pophelper/articles/index.html 

Francis, R. M. (2017). POPHELPER: an R package and web app to analyse and visualize population structure. Molecular Ecology Resources, 17(1), 27-32. DOI: 10.1111/1755-0998.12509

# example data : https://datadryad.org/stash/dataset/doi:10.5061/dryad.kp11q

### package ape

### ggtree